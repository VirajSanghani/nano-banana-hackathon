/**
 * Gemini 2.5 Flash Image API Integration Service for Vibe-Synth
 * Handles AI-powered image generation and visual art creation
 */

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'

export class GeminiAIService {
  constructor() {
    this.isInitialized = false
    this.init()
  }

  async init() {
    try {
      console.log('üß† Initializing Gemini AI services...')
      
      if (!GEMINI_API_KEY) {
        throw new Error('Gemini API key not configured')
      }
      
      this.isInitialized = true
      console.log('‚úÖ Gemini AI services initialized successfully')
    } catch (error) {
      console.error('‚ùå Failed to initialize Gemini AI services:', error)
      this.isInitialized = false
    }
  }

  /**
   * Generate detailed image prompts using Gemini's text generation
   * @param {Object} emotionData - The emotion analysis data
   * @param {string} emotionData.primaryEmotion - Primary detected emotion
   * @param {number} emotionData.confidence - Confidence level (0-1)
   * @param {Object} emotionData.musicStyle - Musical style properties
   * @returns {Promise<string>} Generated detailed image prompt
   */
  async generateImagePrompt(emotionData) {
    if (!this.isInitialized) {
      throw new Error('Gemini AI service not initialized')
    }

    try {
      const { primaryEmotion, confidence, musicStyle } = emotionData
      
      const systemPrompt = `You are an expert visual artist and synesthete who creates detailed image generation prompts that translate emotions and music into stunning visual art. Your task is to create a detailed, artistic prompt for image generation based on emotional and musical data.

Guidelines:
- Create vivid, artistic descriptions with specific colors, textures, and compositions
- Incorporate the emotion's visual equivalent and musical elements
- Use professional art terminology and techniques
- Include lighting, atmosphere, and mood descriptors
- Keep prompts concise but highly detailed (100-150 words)
- Focus on abstract, artistic interpretations rather than literal representations`

      const userPrompt = `Create a detailed image generation prompt for:
- Primary Emotion: ${primaryEmotion}
- Confidence Level: ${Math.round(confidence * 100)}%
- Musical Style: ${musicStyle ? `${musicStyle.tempo} tempo, ${musicStyle.key} key, ${musicStyle.mood} mood` : 'general'}

Generate a single, detailed artistic prompt that would create a beautiful visual representation of this emotional and musical combination.`

      const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: `${systemPrompt}\n\n${userPrompt}`
            }]
          }],
          generationConfig: {
            temperature: 0.8,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 200,
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status}`)
      }

      const data = await response.json()
      
      if (data.candidates && data.candidates[0] && data.candidates[0].content) {
        const prompt = data.candidates[0].content.parts[0].text.trim()
        console.log('üé® Generated enhanced image prompt:', prompt.substring(0, 100) + '...')
        return prompt
      } else {
        throw new Error('No prompt generated by Gemini')
      }
      
    } catch (error) {
      console.error('‚ùå Failed to generate image prompt:', error)
      
      // Fallback to basic prompt if Gemini fails
      return this.createFallbackPrompt(emotionData)
    }
  }

  /**
   * Create fallback prompt if Gemini API fails
   * @param {Object} emotionData - Emotion data for fallback
   * @returns {string} Basic fallback prompt
   */
  createFallbackPrompt(emotionData) {
    const { primaryEmotion, confidence, musicStyle } = emotionData
    
    const emotionPrompts = {
      joy: "Vibrant golden sunburst with dancing light rays, warm yellows and oranges, uplifting energy, celebration, happiness radiating outward",
      excitement: "Electric energy bolts in bright neon colors, dynamic motion, sparks and lightning, high energy, intense movement, electrifying atmosphere",
      calm: "Serene ocean at sunset, gentle waves, soft blues and purples, peaceful sky, tranquil waters, meditative atmosphere",
      peaceful: "Zen garden with cherry blossoms, soft morning light, pastel colors, gentle breeze, harmony and balance, mindful serenity",
      sadness: "Gentle rain on a window, soft grays and blues, contemplative mood, melancholic beauty, emotional depth, introspective",
      anger: "Intense fire and molten lava, bold reds and oranges, powerful energy, dramatic lighting, raw emotion, fierce intensity",
      fear: "Mysterious shadowy forest, deep purples and dark blues, ethereal mist, tension in the air, mysterious atmosphere",
      surprise: "Explosive starburst of rainbow colors, unexpected patterns, bright contrasts, dynamic composition, wonder and amazement",
      love: "Soft rose petals floating in warm light, gentle pinks and golds, romantic atmosphere, heart-warming glow, tender emotion",
      hope: "Dawn breaking over mountains, soft golden light, inspiring vista, new beginnings, optimistic colors, uplifting scene",
      nostalgia: "Vintage sepia-toned memories, old photographs, warm amber light, soft focus, bittersweet beauty, time-worn elegance"
    }

    const basePrompt = emotionPrompts[primaryEmotion] || emotionPrompts.calm
    const intensityModifier = confidence > 0.8 ? "highly intense, vivid, dramatic" : 
                             confidence > 0.6 ? "moderate intensity, clear" : 
                             "subtle, gentle, soft"
    
    const musicStyleModifier = musicStyle ? 
      `with ${musicStyle.tempo} rhythm patterns, in ${musicStyle.key} tonal qualities, ${musicStyle.mood} aesthetic` : 
      ""

    return `${basePrompt}, ${intensityModifier}, ${musicStyleModifier}, abstract art style, digital painting, high quality, artistic, emotional expression, beautiful composition`
  }

  /**
   * Analyze text for emotional content using Gemini
   * @param {string} text - Text to analyze
   * @returns {Promise<Object>} Emotion analysis results
   */
  async analyzeEmotionalContent(text) {
    if (!this.isInitialized) {
      throw new Error('Gemini AI service not initialized')
    }

    try {
      console.log('üß† Analyzing emotional content with Gemini...')
      
      const prompt = `Analyze the emotional content of this text and provide a JSON response with the following structure:
{
  "primaryEmotion": "emotion_name",
  "confidence": 0.0-1.0,
  "emotions": [
    {"emotion": "name", "intensity": 0.0-1.0}
  ],
  "musicStyle": {
    "tempo": "slow/moderate/fast",
    "key": "major/minor",
    "mood": "description"
  },
  "visualElements": ["color1", "color2", "texture", "atmosphere"]
}

Emotions to consider: joy, sadness, anger, fear, surprise, love, hope, excitement, calm, peaceful, nostalgia

Text to analyze: "${text}"`

      const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.3,
            topK: 20,
            topP: 0.8,
            maxOutputTokens: 300,
          }
        })
      })

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status}`)
      }

      const data = await response.json()
      
      if (data.candidates && data.candidates[0] && data.candidates[0].content) {
        const responseText = data.candidates[0].content.parts[0].text.trim()
        
        try {
          // Extract JSON from response
          const jsonMatch = responseText.match(/\{[\s\S]*\}/)
          if (jsonMatch) {
            const emotionData = JSON.parse(jsonMatch[0])
            console.log('‚úÖ Emotional analysis complete:', emotionData)
            return emotionData
          }
        } catch (parseError) {
          console.warn('Failed to parse Gemini emotion analysis, using fallback')
        }
      }
      
      // Fallback emotion analysis
      return this.createFallbackEmotionAnalysis(text)
      
    } catch (error) {
      console.error('‚ùå Failed to analyze emotional content:', error)
      return this.createFallbackEmotionAnalysis(text)
    }
  }

  /**
   * Create fallback emotion analysis
   * @param {string} text - Original text
   * @returns {Object} Basic emotion analysis
   */
  createFallbackEmotionAnalysis(text) {
    // Simple keyword-based emotion detection as fallback
    const emotionKeywords = {
      joy: ['happy', 'joy', 'excited', 'wonderful', 'amazing', 'great', 'fantastic'],
      sadness: ['sad', 'depressed', 'down', 'upset', 'crying', 'tears', 'lonely'],
      anger: ['angry', 'mad', 'furious', 'annoyed', 'frustrated', 'rage'],
      love: ['love', 'adore', 'cherish', 'heart', 'romantic', 'beautiful'],
      fear: ['afraid', 'scared', 'frightened', 'worried', 'nervous', 'anxious'],
      calm: ['calm', 'peaceful', 'relaxed', 'serene', 'tranquil', 'quiet']
    }

    const textLower = text.toLowerCase()
    let detectedEmotion = 'calm'
    let confidence = 0.5

    for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
      const matches = keywords.filter(keyword => textLower.includes(keyword))
      if (matches.length > 0) {
        detectedEmotion = emotion
        confidence = Math.min(0.8, 0.3 + (matches.length * 0.2))
        break
      }
    }

    return {
      primaryEmotion: detectedEmotion,
      confidence,
      emotions: [{ emotion: detectedEmotion, intensity: confidence }],
      musicStyle: {
        tempo: confidence > 0.6 ? 'fast' : 'moderate',
        key: ['joy', 'love', 'excitement'].includes(detectedEmotion) ? 'major' : 'minor',
        mood: detectedEmotion
      },
      visualElements: ['blue', 'purple', 'gradient', 'soft']
    }
  }

  /**
   * Check service health and connectivity
   * @returns {Promise<Object>} Service status
   */
  async healthCheck() {
    try {
      if (!GEMINI_API_KEY) {
        return {
          status: 'error',
          connected: false,
          error: 'API key not configured'
        }
      }

      // Simple test request
      const testResponse = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: 'Hello, respond with just "OK"'
            }]
          }],
          generationConfig: {
            maxOutputTokens: 10,
          }
        })
      })

      if (testResponse.ok) {
        return {
          status: 'healthy',
          connected: true,
          service: 'Gemini 2.5 Flash'
        }
      } else {
        return {
          status: 'error',
          connected: false,
          error: `HTTP ${testResponse.status}`
        }
      }
    } catch (error) {
      return {
        status: 'error',
        connected: false,
        error: error.message
      }
    }
  }
}

// Create singleton instance
export const geminiAI = new GeminiAIService()

// Export individual functions for direct use
export const generateImagePrompt = (emotionData) => geminiAI.generateImagePrompt(emotionData)
export const analyzeEmotionalContent = (text) => geminiAI.analyzeEmotionalContent(text)
export const checkGeminiHealth = () => geminiAI.healthCheck()

export default geminiAI